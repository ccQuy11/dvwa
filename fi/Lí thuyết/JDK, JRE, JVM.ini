JDK, JVM, và JRE khác nhau như thế nào? Vai trò của từng thành phần trong hệ sinh thái Java?
Answer:
JVM (Java Virtual Machine)	Máy ảo thực thi bytecode Java, đảm bảo tính đa nền tảng ("Write Once, Run Anywhere").
JRE (Java Runtime Environment)	Bao gồm JVM + thư viện chuẩn (ví dụ: java.lang, java.util) để chạy ứng dụng Java.
JDK (Java Development Kit)	Bao gồm JRE + công cụ phát triển (compiler javac, debugger, Javadoc) để lập trình Java.
==) Khác nhau:
JVM là thành phần nền tảng Java thực thi các chương trình của bạn.
JRE khởi tạo JVM và đảm bảo các phụ thuộc có sẵn cho các chương trình của bạn.
JDK cho phép bạn tạo các chương trình Java có thể được thực thi và chạy bởi JVM và JRE.

Vai trò:
JRE có trách nhiệm chính là tạo môi trường để thực thi mã nguồn
JVM chỉ định tất cả các triển khai. Nó có trách nhiệm cung cấp tất cả các triển khai này cho JRE
DK bao gồm nhiều công cụ để gỡ lỗi, giám sát và phát triển các ứng dụng Java

JDK có những công cụ nào quan trọng cho lập trình viên Java?
Answer:
javac (Compiler): Biên dịch mã nguồn Java thành bytecode. 
java (Interpreter): Chạy các ứng dụng Java đã được biên dịch. 
jar (Archiver): Tạo các tập tin JAR, cho phép gói các lớp, tài nguyên và các thành phần khác lại với nhau. 
javadoc (Documentation generator): Tạo tài liệu API cho ứng dụng Java. 
javap (Decompiler): Giúp phân tích, hiển thị thông tin về các lớp Java. 
Debuggers: Giúp gỡ lỗi và tìm hiểu sâu hơn về mã nguồn. 
Other development tools: Bao gồm nhiều công cụ khác hỗ trợ cho việc phát triển, như keytool (quản lý kho khóa), policytool (quản lý chính sách), wsimport (tạo các lớp Java từ các dịch vụ web), xjc (tạo các lớp Java từ các lược đồ XML), jps, jstat, jmc, jstack, jcmd
javac (Compiler): Biên dịch mã nguồn Java thành bytecode. 
java (Interpreter): Chạy các ứng dụng Java đã được biên dịch. 
jar (Archiver): Tạo các tập tin JAR, cho phép gói các lớp, tài nguyên và các thành phần khác lại với nhau. 
javadoc (Documentation generator): Tạo tài liệu API cho ứng dụng Java. 
javap (Decompiler): Giúp phân tích, hiển thị thông tin về các lớp Java. 
Debuggers: Giúp gỡ lỗi và tìm hiểu sâu hơn về mã nguồn. 
Other development tools: Bao gồm nhiều công cụ khác hỗ trợ cho việc phát triển, như keytool (quản lý kho khóa), policytool (quản lý chính sách), wsimport (tạo các lớp Java từ các dịch vụ web), xjc (tạo các lớp Java từ các lược đồ XML), jps, jstat, jmc, jstack, jcmd

JVM hoạt động như thế nào khi bạn chạy một chương trình Java?
Answer:
1. Biên dịch mã nguồn:
Chương trình Java được biên dịch bằng trình biên dịch (javac) thành mã bytecode. 
2. Tải mã bytecode:
JVM tải mã bytecode vào bộ nhớ. 
3. Thực thi mã:
JVM thực thi từng lệnh trong mã bytecode, thông qua Execution Engine, chuyển đổi các lệnh đó thành mã máy có thể thực thi trên hệ thống. 
4. Quản lý bộ nhớ:
JVM quản lý bộ nhớ để lưu trữ các đối tượng, dữ liệu và thông tin liên quan đến ứng dụng. 
5. Xử lý ngoại lệ:
JVM xử lý các ngoại lệ xảy ra trong quá trình thực thi chương trình. 

Có những thành phần quan trọng nào bên trong JVM?
Answer:
Bộ nạp lớp (Class Loader): 
Trách nhiệm chính của bộ nạp lớp là tải các file lớp (class file) và các tài nguyên khác của ứng dụng Java vào bộ nhớ để JVM có thể thực thi.
JVM sử dụng các loại class loader khác nhau để quản lý các loại lớp khác nhau (ví dụ: bootstrap class loader và các class loader tùy chỉnh).
2. Các vùng nhớ (Memory Area): 
Heap:
Đây là vùng nhớ chính nơi các đối tượng Java được cấp phát và quản lý.
Stack:
Ngăn xếp lưu trữ các kết quả từng phần và các biến cục bộ của một chương trình, mỗi luồng sẽ có một ngăn xếp riêng.
Method Area:
Lưu trữ các thông tin về lớp (ví dụ: cấu trúc của lớp, phương thức, trường).
Program Counter Register:
Lưu trữ địa chỉ của lệnh JVM hiện đang được thực thi.
Native Method Stack:
Lưu trữ các phương thức gốc (native method) được sử dụng trong ứng dụng, thường được viết bằng ngôn ngữ khác Java.
3. Execution Engine: 
Execution Engine có trách nhiệm thực thi mã bytecode của Java.
Nó bao gồm các thành phần như trình thông dịch (Interpreter) và trình biên dịch Just-In-Time (JIT Compiler).
Trình thông dịch đọc và thực thi các hướng dẫn bytecode từng bước, trong khi JIT Compiler biên dịch các phần bytecode thường xuyên thành mã máy để cải thiện hiệu suất.
4. Java Native Interface (JNI):
JNI cho phép JVM tương tác với các chương trình được viết bằng ngôn ngữ khác (ví dụ: C, C++). 
JNI giúp JVM thực hiện các thao tác liên quan đến hệ điều hành hoặc các thư viện bên ngoài. 

JVM quản lý bộ nhớ như thế nào? Các vùng nhớ quan trọng trong JVM là gì?
Answer:
Trong Java, việc quản lý bộ nhớ được JVM xử lý tự động để lưu trữ các biến, lớp, trường,  được chia ra thành hai vùng. Một trong số chúng được gọi là Stack và cái còn lại là Heap.
STACK:  là cách tiếp cận rất hiệu quả để quản lý bộ nhớ và không chỉ một mà mọi luồng đều có vùng ngắn xếp riêng do các trường được khởi tạo lần lượt được thêm vào bộ nhớ giống như cách chúng ta xếp chồng nó lên nhau. 
HEAP: là nơi lưu trữ các đối tượng và mảng. Nó được chia thành hai phần: Young Generation (bao gồm Eden Space và Survivor Spaces) và Old Generation (hoặc Tenured Space). Young Generation là nơi mới tạo ra các đối tượng, trong khi Old Generation chứa các đối tượng sống lâu hơn.  

Class Metadata (Method Area) trong JVM có vai trò gì?
Answer:
Dùng để lưu trữ cấu trúc của các class, bao gồm tên class, thông tin về các trường và phương thức của class, cũng như mã bytecode của các phương thức.
Mô tả và vị trí của hệ thống và các thành phần của nó.
Nó cũng có Tên, định nghĩa, nội dung và cấu trúc của dữ liệu và chế độ xem của người dùng cuối.
Xác định dữ liệu có thẩm quyền.
Các quy tắc tích hợp và chuyển đổi được sử dụng để điền dữ liệu.
Thông tin đăng ký của người đăng ký.
Được sử dụng để phân tích hiệu suất và mức sử dụng dữ liệu.
https://www.educba.com/metadata-in-java/
https://viblo.asia/p/gioi-thieu-ve-java-virtual-machine-jvm-gwd43M6qLX9

PermGen và Metaspace khác nhau như thế nào? Tại sao Java chuyển từ PermGen sang Metaspace từ Java 8?
Answer:
Metaspace theo mặc định tự động tăng kích thước của nó (lên đến mức mà hệ điều hành cơ bản cung cấp), trong khi PermGen có kích thước cố định và cần được cấu hình thủ công.
PermGen (Permanent Generation) là vùng nhớ trong JVM trước Java 8, dùng để lưu trữ metadata của lớp, bao gồm thông tin về các lớp đã nạp, phương thức, trường, v.v.
Metaspace là vùng nhớ mới trong Java 8, thay thế cho PermGen, và lưu trữ metadata của lớp trong bộ nhớ ngoài heap, cho phép tự động mở rộng kích thước mà không cần cấu hình thủ công.
Metaspace không giới hạn kích thước như PermGen, giúp tránh lỗi OutOfMemoryError liên quan đến PermGen khi nạp nhiều lớp. 
https://dzone.com/articles/java-8-permgen-metaspace
https://www.infoq.com/articles/Java-PERMGEN-Removed/

Heap và Stack trong JVM khác nhau như thế nào?
Answer:
Số lượng: HEAP có 1 còn STACK có nhiều vùng nhớ.
Heap được quản lý bởi Garbage Collector (GC) trong JVM, trong khi Stack được quản lý theo LIFO (Last In First Out) và mỗi luồng có một Stack riêng.
Kích thước bộ nhớ:
- HEAP: không cố định, có thể tăng giảm để đáp ứng như cầu chương Trình
- STACK: Cố định, tùy thuộc hệ điều hành
Đặc điểm
- HEAP: được quản lí bởi lập trình viên
- STACK: được quản lí bởi hệ thống
https://viblo.asia/p/su-khac-nhau-giua-bo-nho-heap-va-bo-nho-stack-trong-lap-trinh-E375zQb1lGW

Garbage Collection trong JVM là gì? Tại sao nó quan trọng?
Answer:
Là một quá trình tự động quản lý bộ nhớ trong các ngôn ngữ lập trình như Java. Mục đích chính của GC là giải phóng bộ nhớ không còn được sử dụng bởi chương trình, giúp tránh tình trạng thiếu bộ nhớ (memory leaks) và làm cho việc lập trình trở nên dễ dàng hơn.
Trong các ngôn ngữ lập trình không có hỗ trợ GC, việc quản lý bộ nhớ trở nên phức tạp và gây nên lỗi khó tìm và sửa chữa. Ngược lại, GC giúp giảm bớt gánh nặng cho lập trình viên, cho phép họ tập trung vào việc phát triển tính năng của ứng dụng mà không phải lo lắng về việc quản lý bộ nhớ một cách chi tiết.


Những thuật toán chính của Garbage Collection mà JVM sử dụng là gì?
Answer:
Serial GC: sử dụng một luồng (thread) cho việc thu thập rác và dừng toàn bộ ứng dụng trong quá trình thu gom rác, gọi là stop-the-world (STW), sử dụng mặc định trong các ứng dụng Java nhỏ và đơn giản, không yêu cầu xử lý dữ liệu lớn và đòi hỏi tài nguyên bộ nhớ thấp.
Parallel GC: sử dụng multiple threads để thu thập rác trên bộ nhớ heap, được thiết kế để tận dụng các bộ vi xử lý có nhiều lõi, giúp tăng tốc độ thu gom rác bằng cách sử dụng nhiều thread đồng thời.
Concurrent Mark Sweep (CMS) GC: được thiết kế để giảm thiểu độ trễ (latency) trong quá trình thu gom rác bằng cách sử dụng nhiều luồng để thực hiện việc thu gom rác. Nó được chia làm 4 giai đoạn:
- Initial Mark: tạm dừng tất cả các luồng thực thi và xác định các đối tượng trực tiếp được tham chiếu bởi các biến tĩnh, biến stack và các thanh ghi CPU. Các đối tượng này được đánh dấu là "live".
- Concurrent Mark:chạy các luồng thu gom rác để xác định các đối tượng "live" khác bằng cách truy xuất các đối tượng đã được đánh dấu trong Initial Mark, được thực hiện song song với luông chính của ứng dụng
- Remark:  tạm dừng tất cả các luồng thực thi và xác định các đối tượng "live" mới được tham chiếu trong quá trình Concurrent Mark.
- Concurrent Sweep: chạy các luồng thu gom rác để giải phóng các đối tượng không còn được sử dụng. Quá trình này được thực hiện song song với luồng chính của ứng dụng.
Garbage First (G1) GC: được thiết kế để giải quyết các vấn đề về hiệu suất và khả năng mở rộng của CMS GC, đồng thời giảm thiểu độ trễ (latency) trong quá trình thu gom rác. G1 GC được chia thành các vùng (regions) bằng cách chia bộ nhớ heap thành các khu vực bằng nhau, tập trung vào các vùng có nhiều đối tượng rác, sử dụng các vòng lặp thu gom rác được điều khiển bởi jvm từ đó rút ngắn và phân tán các hoạt động thu gom rác trong nhiều chu kỳ thu gom rác, giảm thiểu độ trễ và tăng hiệu suất bằng cách xử lí đa luồng. Có thể xử lí các tệp HEAP lớn mà không ảnh hưởng hiệu suất nhưng tốn thời gian hoặc các regions quá nhỏ hoặc nếu đối tượng ít
Z Garbage Collector (ZGC):  được thiết kế để hỗ trợ các ứng dụng Java đòi hỏi tính khả dụng cao và thời gian phản hồi thấp, quan trong với các ứng dụng trò chơi hoặc xử lí dữ liệu thời gian thực. Có nhiều tính năng như tự động điều chỉnh kích thước bộ nhớ, giảm thời gian phản hồi, duy trì khả năng tùy chỉnh cao, hỗ trợ các hệ thống có nhiều nhân xử lí.
Shenandoah GC: là thuật toán mới, thuộc loại Concurrent, có khả năng giảm thiểu độ trễ với tối ưu hiệu suất sử dụng, có thể thực hiện với bất kì kích thước heap nào, không cần phải dừng toàn bộ ứng dụng trong quá trình thu gom rác, giúp giảm thiểu độ trễ và tăng hiệu suất của ứng dụng. Shenandoah GC sử dụng các thuật toán như Concurrent Marking, Concurrent Evacuation và Concurrent Cleanup để thu gom rác một cách hiệu quả.
https://viblo.asia/p/garbage-collection-gc-trong-jvm-Yym40YE9J91#_34-garbage-first-g1-gc-8
https://medium.com/@agayevrauf/exploring-the-different-kinds-of-garbage-collectors-in-java-7e1f10017c6a

JVM có những loại Garbage Collector nào? Khác nhau ở điểm nào?
Answer:
Các loại Garbage Collector trong JVM: xem trong câu hỏi trên 
Điểm khác nhau:
- Serial GC: Sử dụng một luồng, dừng toàn bộ ứng dụng trong quá trình thu gom rác, phù hợp với ứng dụng nhỏ.
- Parallel GC: Sử dụng nhiều luồng để thu gom rác, tăng tốc độ thu gom rác bằng cách sử dụng nhiều thread đồng thời, phù hợp với ứng dụng có dữ liệu lớn.
- CMS GC: Giảm thiểu độ trễ bằng cách sử dụng nhiều luồng, chia quá trình thu gom rác thành các giai đoạn, phù hợp với ứng dụng cần thời gian phản hồi thấp.
- G1 GC: Chia bộ nhớ heap thành các vùng, tập trung vào các vùng có nhiều đối tượng rác, sử dụng các vòng lặp thu gom rác để giảm thiểu độ trễ, phù hợp với ứng dụng cần hiệu suất cao và khả năng mở rộng.
- ZGC: Hỗ trợ tính khả dụng cao và thời gian phản hồi thấp, tự động điều chỉnh kích thước bộ nhớ, phù hợp với ứng dụng trò chơi hoặc xử lý dữ liệu thời gian thực.
- Shenandoah GC: Giảm thiểu độ trễ, không dừng toàn bộ ứng dụng trong quá trình thu gom rác, sử dụng các thuật toán Concurrent Marking, Concurrent Evacuation và Concurrent Cleanup, phù hợp với ứng dụng cần hiệu suất cao và thời gian phản hồi thấp.

Sự khác biệt giữa Minor GC, Major GC và Full GC là gì?
Answer:
Minor GC: là quá trình thu gom rác trong Young Generation, nơi chứa các đối tượng mới được tạo ra. Quá trình này thường diễn ra thường xuyên và nhanh chóng, giúp giải phóng bộ nhớ cho các đối tượng mới.
Major GC: là quá trình thu gom rác trong Old Generation, nơi chứa các đối tượng đã sống lâu hơn. Quá trình này thường diễn ra ít thường xuyên hơn so với Minor GC và có thể mất nhiều thời gian hơn, vì nó cần phải kiểm tra và giải phóng các đối tượng lớn hơn.   
Full GC: là quá trình thu gom rác toàn bộ bộ nhớ heap, bao gồm cả Young Generation và Old Generation. Quá trình này thường diễn ra khi bộ nhớ heap đầy hoặc khi có yêu cầu giải phóng bộ nhớ lớn. Full GC có thể mất nhiều thời gian và ảnh hưởng đến hiệu suất của ứng dụng, vì nó cần phải kiểm tra và giải phóng tất cả các đối tượng trong bộ nhớ heap.

Bộ nhớ Stack có bị thu hồi bởi Garbage Collector không? Nếu không, nó được quản lý như thế nào?
Answer:
Bộ nhớ Stack không bị thu hồi bởi Garbage Collector (GC) trong JVM. Thay vào đó, nó được quản lý theo cơ chế Last In First Out (LIFO), nghĩa là các khung ngăn xếp (stack frame) được tạo ra khi một phương thức được gọi sẽ được giải phóng khi phương thức đó kết thúc. Mỗi luồng trong ứng dụng Java có một ngăn xếp riêng, và khi luồng kết thúc, toàn bộ ngăn xếp của nó sẽ được giải phóng tự động. Do đó, không cần phải lo lắng về việc thu hồi bộ nhớ Stack như với Heap.
Garbage Collector có thể thu hồi bộ nhớ Heap nhưng không thu hồi bộ nhớ Stack. Bộ nhớ Stack được quản lý tự động bởi JVM, mỗi khi một phương thức được gọi, một khung ngăn xếp mới sẽ được tạo ra và khi phương thức kết thúc, khung ngăn xếp đó sẽ được giải phóng.


Làm thế nào để tránh Memory Leak trong Java?
Answer:
1. Sử dụng Weak References: Sử dụng WeakReference hoặc SoftReference để giữ các đối tượng mà không ngăn chúng bị thu hồi bởi Garbage Collector.
2. Giải phóng tài nguyên: Đảm bảo giải phóng các tài nguyên như kết nối cơ sở dữ liệu, luồng, và các đối tượng I/O khi không còn sử dụng nữa.
3. Sử dụng try-with-resources: Sử dụng cấu trúc try-with-resources để tự động đóng các tài nguyên khi không còn sử dụng.
4. Tránh giữ tham chiếu không cần thiết: Tránh giữ các tham chiếu đến các đối tượng không còn cần thiết, ví dụ như các đối tượng trong danh sách hoặc mảng.
5. Sử dụng công cụ phân tích bộ nhớ: Sử dụng các công cụ như VisualVM, Eclipse Memory Analyzer (MAT) để phát hiện và phân tích các vấn đề liên quan đến bộ nhớ.
6. Theo dõi và kiểm tra bộ nhớ: Sử dụng các công cụ giám sát bộ nhớ để theo dõi việc sử dụng bộ nhớ của ứng dụng và phát hiện các vấn đề liên quan đến Memory Leak.

JIT Compiler trong JVM là gì? Nó cải thiện hiệu năng như thế nào?
Answer:
JIT Compiler (Just-In-Time Compiler) là một thành phần của JVM, có nhiệm vụ biên dịch mã bytecode thành mã máy thực thi ngay khi cần thiết, thay vì biên dịch toàn bộ mã trước khi chạy. Điều này giúp cải thiện hiệu năng của ứng dụng Java bằng cách:
1. Tối ưu hóa mã: JIT Compiler có thể áp dụng các tối ưu hóa dựa trên thông tin runtime, giúp mã máy được tạo ra hiệu quả hơn.
2. Giảm thời gian khởi động: Bằng cách biên dịch mã khi cần thiết, JIT Compiler giúp giảm thời gian khởi động của ứng dụng, vì không cần phải biên dịch toàn bộ mã trước khi chạy.
3. Tăng tốc độ thực thi: Mã máy được biên dịch bởi JIT Compiler thường chạy nhanh hơn so với mã bytecode, vì nó được tối ưu hóa cho kiến trúc phần cứng cụ thể.


Khi nào JIT Compiler dịch mã bytecode sang mã máy thực thi?
Answer:
JIT Compiler dịch mã bytecode sang mã máy thực thi khi:
1. Mã bytecode được gọi nhiều lần: JIT Compiler sẽ theo dõi các phương thức và đoạn mã được gọi nhiều lần trong quá trình thực thi. Khi một phương thức hoặc đoạn mã được gọi đủ số lần nhất định, JIT Compiler sẽ biên dịch nó thành mã máy để cải thiện hiệu suất.
2. Khi JVM xác định rằng việc biên dịch mã bytecode sẽ mang lại lợi ích về hiệu suất: JIT Compiler sẽ quyết định biên dịch mã bytecode thành mã máy dựa trên các yếu tố như tần suất gọi, thời gian thực thi, và các tối ưu hóa có thể áp dụng.

Khi ứng dụng Java chạy chậm, bạn sẽ kiểm tra gì đầu tiên?
Answer:
Khi ứng dụng Java chạy chậm, tôi sẽ kiểm tra các yếu tố sau:
1. Hiệu suất Garbage Collection: Kiểm tra xem có quá nhiều Full GC hoặc Minor GC không, và thời gian GC có ảnh hưởng đến hiệu suất không.
2. Sử dụng bộ nhớ: Kiểm tra mức sử dụng bộ nhớ của ứng dụng, xem có Memory Leak hay không, và các đối tượng trong Heap có được giải phóng đúng cách không.
3. Tối ưu hóa mã: Phân tích mã nguồn để tìm các đoạn mã không hiệu quả, vòng lặp lồng nhau, hoặc các thuật toán có độ phức tạp cao.
4. Sử dụng công cụ giám sát: Sử dụng các công cụ như VisualVM, JProfiler, hoặc Java Mission Control để theo dõi hiệu suất và tìm ra các nút thắt cổ chai (bottlenecks) trong ứng dụng.


Làm thế nào để debug lỗi liên quan đến bộ nhớ Heap và Stack?
Answer:
Để debug lỗi liên quan đến bộ nhớ Heap và Stack, tôi sẽ thực hiện các bước sau:
1. Sử dụng công cụ phân tích bộ nhớ: Sử dụng các công cụ như Eclipse Memory Analyzer (MAT) hoặc VisualVM để phân tích Heap Dump và Stack Trace, giúp xác định các đối tượng không được giải phóng hoặc các luồng bị chặn.
2. Kiểm tra Stack Trace: Xem Stack Trace để xác định vị trí của lỗi và các phương thức liên quan, giúp tìm ra nguyên nhân gốc rễ của vấn đề.
3. Sử dụng công cụ giám sát: Sử dụng các công cụ giám sát như JConsole hoặc Java Mission Control để theo dõi việc sử dụng bộ nhớ và hiệu suất của ứng dụng trong thời gian thực.
4. Thực hiện profiling: Sử dụng các công cụ profiling như JProfiler hoặc YourKit để theo dõi hiệu suất của ứng dụng, xác định các nút thắt cổ chai và các vấn đề liên quan đến bộ nhớ.
5. Thực hiện kiểm tra mã: Kiểm tra mã nguồn để tìm các vấn đề liên quan đến việc quản lý bộ nhớ, như không giải phóng tài nguyên, giữ tham chiếu không cần thiết, hoặc sử dụng các cấu trúc dữ liệu không hiệu quả.
